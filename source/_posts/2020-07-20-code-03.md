---
layout: post
categories: Software
title: 编码技巧（三）：不吝口舌

---

### 背景

前几篇文章中，我们介绍了有关 “信息表达” 方面的编码技巧，

（1） “让主流程清晰”：尽可能少的在主流程中堆放不相关的内容。

（2） “提取工具”：组装更大的信息块，避免频繁的应对细节。

<br/>

这两个技巧，所做的都是尽可能的**少**的披露内容，

减少阅读者一次感受到的信息量，有助于抓住重点看清脉络。

<br/>

然而，这是不是意味着代码写的越**少**越好呢？

其实不然。

<br/>

因为信息是以**编码**形式 “固化” 下来的，

在总信息量一定的情况下，

代码越少信息**密度**就越大，每行代码理解起来也就越困难。

<br/>

所以我们不该**吝啬**编码，谨防矫枉过正。

### 代码 + 文档

有一句流传很广的行业说法，“好的代码本身就是文档”。

这是人们对 “好代码” 的高度赞扬。

是想说 “好代码” 太容易理解了，简直不需要再另写文档了。

<br/>

可这并不意味着，没有文档的代码就是 “好代码”。

<br/>

所以，我们得有**自知之明**，如果还写不出优秀代码的话，

多写点解释性质的注释和文档，也是没办法的事情，

如果我们无法言简意赅的说清自己的意图，就只能多啰嗦几句。

<br/>

如果代码本身写的就难以理解，还没有解释说明，

不是更难被理解了吗？

<br/>

在我看来，“代码 + 文档” 才是开发者应写出的最终**产物**，

只有代码还不够，来看下文分析。

### 代码的局限性

代码是交给机器运行的，机器并**不需要**知道太多信息，

它只管照做就行了，不用关心为什么要这样做。

<br/>

为代码的维护者就不能如此了，除了代码的执行逻辑之外，

维护者还得知道，代码之所这样写而不是那样写的**原因**。

<br/>

这些 “原因” 是难以编码到代码中的，必须以文档或注释的方式保存下来。

不然真的就 “失传” 了，这就是代码的**局限性**。

<br/>

认识到代码局限性的开发者，往往能写出包含信息量**更全**的代码，

不论是从变量的命名，还是逻辑的展现上来看，

他们都在试图传递**更多**的信息。

<br/>

一个常见的误区是，

认为所有的逻辑都在代码中，认为理解业务的最好办法是阅读源码。

<br/>

这样的编码认知，非常的短浅。

### 当心 1 + 1 > 2

一个大型系统被划分为几个部分之后，并没有降低**整体**复杂度。

而只是降低了**临层**之间的管理复杂度。

<br/>

所以，把一个团队划分为十个小组，整体来看一定是更复杂了，

但管理这十个小组，对比起直接管理所有成员来说，负担却更小了一些。

<br/>

除此之外，划分为多个部分后的系统，整体**业务量**也会有所增加。

<br/>

因为每个子系统，都得独立对外，规范的写清自己的边界范围。

当前系统提供了哪些服务？其他系统怎样与之交互？怎样跟踪错误如何排查问题？

这些都是**工作量**，不是自然而然就有的。

<br/>

从这种意义上来看，一加一就大于二了。

<br/>

上一篇文章中我们也提到过，不要轻易的提供 “复用”，

在这里也是异曲同工。

<br/>

独立模块、系统，需要输出更多的信息，需要更多的维护成本。

尤其当**对外**提供服务时。

### 结语

在编码过程中会发现有些内容，只用代码没办法交代清楚，

这时候就不应该**吝啬**笔墨了。

<br/>

多写一些注释，多写一些文档，并不意味着我们写不好代码。

反而恰恰意味着，我们对代码的**局限性**有更深的自知之明。

<br/>

最后，独立系统的 “使用文档”，经常被人忽视，

事实上，如果别人不知道如何使用的话，那其实就相当于没有提供功能。

<br/>

所以，好代码虽然会讲究信息披露的必要性，但仍然会传达出**足够**的信息，

给人一种 “想了解的都在那里” 的感觉。

<br/>

正所谓：君子坦荡，事无不可对人言。
