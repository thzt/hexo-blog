---
layout: post
categories: Mind
title: 创造用户价值
---

我们知道，**产品**是为提供**用户价值**服务的，

它解决了用户问题，从而创造了商业价值，

因此，用户才肯花钱购买产品，企业有了**利润**才能活下去。

<br/>

虽然如此，但是在产品**生产过程**中的每一个环节，

都能保持**客户第一**的清醒认识，也是不容易的。

<br/>

例如，在安排任务的时候，我们会考虑事情的**优先级**，

也会考虑**投入产出比**，甚至会优先选择**容易实现**的功能点，

在局部上，我们可能难以断言，所做的事情，能带来多大的用户价值。

<br/>

因此，这就带来了几方面的问题，

本文来探讨一下这些场景。

<br/>

### 1. 完整的需求规格

完整的需求规格，事实上，远比产品经理所表述的那些还要多。

例如，系统的异常流，简直随着系统规模呈指数级的增长。

<br/>

大家可能有过这样的感受，

我们用了**20%**的时间，就能看似完成系统的大部分功能，

而剩下的那些细节，越经常会消耗掉**80%**以上的时间。

<br/>

我认为这是[帕累托法则](https://zh.wikipedia.org/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%B3%95%E5%88%99)（二八定律），

在软件开发实践中的体现。

<br/>

此外，我们对正常业务逻辑的理解，

也会随着工作的进展，逐渐变得透彻起来，

交付阶段我们认识到的逻辑**复杂度**，与刚开始时简直不可同日而语。

<br/>

因此，为了交付完整的用户价值，

就必须尽快理解清，需求的所有细节，

尽快投入到后80%的开发时间中去。

<br/>

在前20%的开发阶段，对需求的全貌过于乐观，是项目延期的主要原因之一。

<br/>

### 2. 简化需求

先实现出一版功能的**轮廓**，然后再持续不断的进行**完善**，

这也是软件开发过程中的一种常见手法。

<br/>

这样做其实没什么问题。

<br/>

无非会稍微增加一些返工的成本，

如果一开始就对问题有了透彻理解，再**选择**这样的开发方式来迭代，

那就更没有什么问题了。

<br/>

可是，这样的开发方式，却经常伴随着一种**不良的习惯**，

那就是有意在**交付阶段**对需求进行**简化**。

开发者不愿意交付完整的功能点。

<br/>

这样其实是危害极大的。

实际上，实现一个简化版的功能，比实现完整的功能点，要容易太多了。

某个简单的定制化需求，可能会产生**复杂好几倍**的软件。

<br/>

当然我们也知道业务架构不清的情况下，代码结构也不会清晰，

不过我们现在暂时不准备讨论这些。

<br/>

所以，如果关心用户价值，那就不要故意简化需求，

即使实现起来很麻烦，

这正是开发者要做的事情，**麻烦才有价值**。

<br/>

### 3. 容易实现

在职业生涯的前几年，我经常会为了某个功能容不容易实现，而跟别人争论，

这件事到现在来看，让我感到非常羞愧。

<br/>

因为，如果简单的实现**满足不了**用户的需要，

那么这种实现，对**最终产品**来说就没有任何意义，

创造不了用户价值。

<br/>

虽然我们有时会考虑到投入产出比，

优先实现更重要，回报率更高的功能点。

但是，这和容易不容易其实没有什么关系。

<br/>

用户要的是**功能**，其实不关心我们是怎么实现的。

实现难以实现的功能点，正是开发者的**本职工作**。

容易实现和不容易实现的功能，**一起**给用户提供了软件服务。

<br/>

所以，如果关心用户价值，那么在讨论实现难度时，就应该保持警惕，

是我们本能的避重就轻，

还是站在了**用户**和**项目按时交付**的角度在考虑问题。

<br/>

### 结语

我们常说客户第一，实际上真正执行起来是很难的，

开发者也很难跳出自己的舒适区，全局性的看待软件的整个交付过程。

<br/>

大多数开发者都是接到了需求，就去实现它，

在遇到困难时，就去**质疑**需求的合理性。

<br/>

其实这样有违**软件系统被研发**的初衷。

<br/>

我们应该从需求的描述中，试图捕捉那些**遗漏**的用户需要，

认识到完整需求的**真实复杂度**，

然后**耐心的，专业的，不嫌麻烦的，不怕困难的**完成它们。

<br/>

我觉得这才是开发者，能为用户价值所做的应有贡献。
