---
layout: post
categories: Design
title: 软件工具的设计艺术
---

### getDefaultProps

在确定软件方案之前，除了要先确定问题之外，还要确定人们到底想不想解决它。

解决某些问题，通常以损失另外的东西为代价，人们是否愿意买单。

此外，为了增加合作的可能性，双方会特意隐瞒需求的细节和实现难度，使之容易达成合作关系。

<br/>

代码不一定要实现产品的所有功能，产品也不一定满足用户的所有的需要。

我们既可以通过设计，满足用户的所有潜在功能，也可以通过限制用户的场景，减少设计复杂度。

<br/>

### getInitialState

编程的艺术在于引入间接性，是否可以把直接的实现，看做是先实现一个工具，再由这个工具来实现原来的目的。

而且，在实现一个工具的过程中，仍然可以再引入间接性。

而艺术本身在于我们引入的间接性在什么程度上是适度的。

<br/>

当用户只需要工具中的部分功能，但又不得不整个工具一起拿过来用时，我们就说这个工具比较重，绑架了用户的选择。

工具的作用，不该是教用户怎么做，而是辅助用户来完成工作，简化已有工作，给用户提供方便。

不要帮用户做所有事情，但也不要所有事情都要用户来做。

<br/>

有的工具是给其它的软件系统用的，而有的工具是给人用的。

我们的工具在什么场景中被使用，是需要事先考虑清楚的，这决定了我们到底提供一个什么样的工具。

<br/>

优秀的开发者，会区分工具提供的功能和自己需要的功能。

如果工具不好用，但是功能完备，那么用的人就会想办法对它包装，让所有其它场景都使用这层包装。

<br/>

### componentWillMount

在考虑该不该的时候，先问目的，该不该做某件事情，还要看解决它是为了达成什么目的。

不考虑目的，讨论任何方法的好坏，都是空想。

<br/>

对软件附加上任何诸如可维护性，可扩展性，可伸缩性，都是需要成本的，我们需要考虑的是这些成本是否值得投入。

没有绝对的错误，只有不够好的选择。

<br/>

只要描述现在的系统没有什么功能，造成了什么不适，就能马上看到需求。

而如果别人直接指出他们需要什么，这很可能只是一种方案。

<br/>

### render

过度设计指的是，软件在被重写之前，我们所担心的事情一次都没有发生。

然而，合理的抽象是必需的，所以关键问题不在于是否进行抽象，而是在于如何进行恰如其分的抽象。

<br/>

不要预测未来，而是想办法让代码具有良好的特征，这些特征让现在的代码更适应变更。

工程师的职责，就是想办法让软件健康成长，是人响应了变更，而不是工具本身。

<br/>

### componentDidMount

能让别人在不看源码的情况下会用，才叫封装。

<br/>

在使用的时候找不到文档，但是在学会之后又不想写下文档。

知识就是这样，缺乏之时如饥似渴，掌握之后就觉得可有可无了。

掌握知识的人，从来都觉得没有分享的必要，而需要这些知识的人们，却觉得走投无路。

<br/>

### componentWillUnmount

软件说白了，无非就是考虑生活中什么可以自动化，以及如何自动化。

编程说白了，无非就是考虑用哪些符号，以及如何用这些符号来解决问题。
