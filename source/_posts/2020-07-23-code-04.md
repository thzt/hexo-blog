---
layout: post
categories: Software
title: 编码技巧（四）：零缺陷

---

### 背景

除了编码之外，开发者平时最常遇到的麻烦就是**软件缺陷**了，

指的是，软件在某些情况下，表现出了与**预期**不符的行为。

<br/>

确保软件没有缺陷，是一件很难的事情，

因为一方面，预期是会**变**的，

另一方面，修改软件的一部分也许会不小心**影响**到其他部分。

<br/>

那么就这样听天由命了么？

很显然这是不行的。

<br/>

写出高缺陷率的代码，是**不专业**的表现。

只有运行起来没问题的代码，再追求清晰易懂才是有意义的。

<br/>

文本就来探讨，如何写出低缺陷代码的编码技巧。

### 亲手测试

在讨论技巧之前，我们不妨先反思一下，

是哪些事实，让我们坚信自己写的代码**肯定**没有问题？

<br/>

我认为只有一条，那就是我们**自己测试**过了。

不论是通过自动化的测试，还是手工测试，

不论是通过肉眼亲见，还是通过逻辑证明。

<br/>

我们应该只相信**自己**测试过的代码。

不能将 ”确保代码没有问题“ 这件事委托给他人。

<br/>

所以，一个**负责任**的开发者，绝不会交付没有经过自测的代码。

让别人找出问题再修复，肯定会耗费更多的时间。

<br/>

这就是为什么有时候改一行代码，也需要很久的原因了，

因为这一行代码，可能会影响到很多其他模块，

这些受影响到的模块，都应**完整的**进行测试。

<br/>

**假设**自己的写的代码没有问题，正是产生问题的根本原因。

### 直面需求

有的人可能要说了，某些缺陷可能并不是编码引起的，

而是因为**需求变更**所致。

<br/>

其实不然。

真实的需求就在那里，绝大多数情况下，变更的都不是需求，

而是对需求的**理解**。

<br/>

产品经理说这样做，就这样实现，说那样做，就那样实现，

这正是**误解需求**的主要原因。

<br/>

为了能够真正的理解需求，开发者应该走在产品经理的前面，

不然代码写完了，发现不满足需求，不是还要修改么？

<br/>

为了能让自己少**改**几次代码，一定得做到比任何人**更懂**需求才行。

### 完整日志

代码未写完之前，日志先行。

大部分的软件缺陷，是由**输入**跟预期不符造成的。

<br/>

意料之外的输入参数，会导致**不确定**的执行结果。

所以，代码逻辑的执行**日志**，

不论对排查问题，还是对编写低缺陷率的代码而言，都是非常重要的。

<br/>

在出现问题的时候，我们必须能**一目了然**的知道问题出在哪里。

经验表明，“问题排查的简易程度” 与 “代码的低缺陷率” 是正相关的。

越容易排错的代码，缺陷率越低。

<br/>

因此，在写代码之前，就得先考虑清楚，

如果我写的代码得到了**奇怪的**结果，要怎么定位问题？

**日志**是行之有效的一种手段。

<br/>

易于定位问题的代码，能有效避免事后很大一堆麻烦事。

### 也谈单测

单测，通常指的是自动化的单元测试，

它是实现单元测试的一种自动化的**手段**，一般是运行一个脚本来执行程序，

再检测执行结果是否跟预期相符。

<br/>

与流行说法不同，我认为写单测其实并**不是**那么重要。

尤其是每次写完代码都要费力**改**好多单测的话，

那还不如不写。

<br/>

上文提到过，确保代码没有缺陷的办法是自己进行完整的**测试**。

至于用什么办法确保，要灵活应对。

<br/>

如果担心别人写的代码，影响了自己负责的功能，是可以写一点单测，

如果需要频繁的构造数据来测试某一块代码，也可以写一点单测，

除此之外，单测真的非常鸡肋。

<br/>

最后，追求单测**覆盖率**，没有太大意义，

“覆盖率” 这个指标，只能检测是否所有代码都**有用**，有没有代码执行不到。

至于执行到的代码有没有错误，覆盖率不关心这些。

<br/>

所以，我们完全可以写出覆盖率 100% 的问题代码。

### 结语

本文讨论了编写高质量（低缺陷率）代码的几个方法：

（1）亲手测试：凡需交付的代码，必完整的亲手测试过

（2）直面需求：做到比任何人更懂需求，才能确保代码跟预期相符

（3）完整日志：代码未写，日志先行，让输入输出一目了然，易于排错

<br/>

还讨论了个人对 “单元测试” 以及 “单测覆盖率” 的看法。

盲目追求漂亮的数字，最终就会自缚手脚。

<br/>

低缺陷率的代码，来源于专业精神，妥协于外力，最后还得自己收拾烂摊子。
