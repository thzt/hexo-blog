---
layout: post
categories: Math
title: 语言背后的代数学（八）：范畴
---

### 回顾
上文中，我们用群，拓扑空间，CPO作为例子，
来说明数学对象之间是如何产生联系的，以及它们具有什么样的运算性质。

同时，我们也看到了这三者在结构上的相似性。
如果把所有的群看做一个整体，所有的拓扑空间看做一个整体，
群同态是否就好比拓扑空间的连续映射了呢？

这种高层的抽象并不是理所当然的，肯定还需要一些约束条件。
为了看清这一点，我们要学习范畴论，
用范畴论方法刻画这些联系。

### 图示法
在前一篇中我们学过了幺半群，
它指的是一个集合$M$，以及$M$上的二元运算$\cdot$，满足以下两个条件，
（1）$\forall x,y,z\in M$，$(x\cdot y)\cdot z=x\cdot (y\cdot z)$，
（2）$\exists e\in M$，$\forall x\in M$，$x\cdot e=e\cdot x=x$。

这两个条件除了可以用等式来表示，还可以用**图**（diagram）来表示，
<pre>&lt;x,y,z&gt; |-------&gt;    &lt;x,yz&gt;<br>   -                   -<br>   |                   |<br>   |                   |<br>   v                   v<br>&lt;xy,z&gt;  |-------&gt; (xy)z=x(yz)</pre>
<pre>&lt;0,x&gt; |-------&gt; &lt;e,x&gt;    &lt;x,e&gt; &lt;-------| &lt;x,0&gt;<br>  -               -        -               -<br>  |               |        |               |<br>  |               |        |               |<br>  v               v        v               v<br>  x       =      ex       xe       =       x</pre>
我们称上图是**可交换的**（commutative），
如果沿着不同的路径进行运算，只要起点和终点相同，则运算的结果就总是相同的。

例如，$<x,y,z>\mapsto <x,yz>\mapsto x(yz)$，
总是等于$<x,y,z>\mapsto <xy,z>\mapsto (xy)z$，
用于表示$M$中的元素具有运算结合律。

又例，$<0,x>\mapsto <e,x>\mapsto ex$，总是等于$<0,x>\mapsto x$。
$<x,0>\mapsto <x,e>\mapsto xe$，总是等于$<x,0>\mapsto x$。
它表示$M$中的存在幺元$e$。

因此，我们用以上两个图表，定义了一个幺半群，
称为**图示法**。

另一方面，考虑在集合论中讨论映射的时候，一般都不写明具体元素，
因此，图示法更常用的写法是这样的，
<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>

<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>
其中，$\mu:M\times M\to M$，$\eta:1\to M$，是两个函数，
$1=\{0\}$是只有一个元素的集合。

这样表示的幺半群，更具有一般性，
它只考虑的对象（$M$）和对象之间的联系（$\mu,\eta$），不用考虑对象中的细节（$M$中的元素）。

### 范畴
有了图示法之后，人们就发现，数学中很多运算系统都可以用这种方法来表示了。
人们把上图中的映射一般化，称为**箭头**（arrow），
把上图中的集合一般化，称为**对象**（object），
然后得到了**范畴**的概念。

一个**范畴**$C$由一系列**对象**（object）和**箭头**（arrow）组成。
对于每一个箭头$f$，有两个对象与之关联，
称为箭头$f$的定义域（domain）和值域（codomain）。

并且，还满足以下几条规则，
（1）对于每一个对象$a$，存在恒等箭头（identity arrow），$i:a\to a$
（2）箭头满足结合律，对于任意的箭头$f,g,h$，有$(f\cdot g)\cdot h=f\cdot (g\cdot h)$
（3）箭头的集合在箭头组合运算下是封闭的

其中，$f\cdot g$表示$g$和$f$的组合运算，
它也是一个箭头，其中$g$的值域是$f$的定义域。

下面我们来看几个范畴的概念，
所有的集合，以集合作为对象，集合间的映射作为箭头，构成了一个范畴，
所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，
所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴，
所有的微分流形，以微分流形作为对象，流形间的光滑映射为箭头，构成了一个范畴，
Haskell中，以类型作为对象，函数作为箭头，构成了一个范畴（**Hask范畴**）。

### 函子
函子就是两个范畴之间的箭头。

一个**函子**$F$是范畴$C$到范畴$D$的箭头，$F:C\to D$，
它满足以下条件，
$F$把$C$中的对象$c$映射为$D$中的对象$F~c$，把$C$中的箭头$f$映射为$D$中的箭头$F~f$。
并且，$F~(f\cdot g)=(F~f)\cdot (F~g)$。

值得注意的是，
等式左边的$\cdot$，表示$C$中的箭头组合运算，
等式右边的$\cdot$，表示$D$中的箭头组合运算。

函子建立了两个范畴之间中的关系，
例如在代数拓扑中，每一个拓扑空间对应了一个基本群，
这种映射关系，就是从拓扑空间范畴到群范畴的函子。

这也是用代数学观点，考虑问题的关键。
我们可以将语义模型，理解为从语法构造到语义解释的一个函子。

范畴$C$到自身的函子，称为**自函子**（endofunctor）。
Hask范畴的自函子把Haskell中的类型$a$映射为另一个类型$f~a$，
把类型$a$到类型$b$的函数，映射为类型$f~a$到类型$f~b$的函数。

例如，
```
class Functor f where
    fmap :: (a -> b) -> f a -> f b

class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
```

我们看到，`pure`和`fmap`放在一起，
构成了一个Hask范畴的自函子。

### 自然变换
自然变换（natural transformation）是一族箭头，
将范畴$A$在一个函子中的像（picture），变换成了另一个函子的像。

给定两个函子$S,T:A\to B$，其中$A$和$B$是范畴。
自然变换的每个分量使下图可交换。
![](http://upload-images.jianshu.io/upload_images/1023733-7a6b0cbdb0347ac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中，$τ_a$是$B$中的箭头，$τ_a:Sa\to Ta$。

{- 自函子T，作用在对象上时 -}
fObj :: (Applicative f) => a -> f a
fObj = pure

{- 自函子T，作用在箭头上时 -}
fArr :: (Applicative f) => (a -> b) -> (f a -> f b)
fArr = fmap

{- 自函子T·T -}
f2Obj :: (Applicative f) => a -> f (f a)
f2Obj = fObj . fObj

f2Arr :: (Applicative f) => (a -> b) -> (f (f a) -> f (f b))
f2Arr :: fArr . fArr

{- 单位自函子，作用到对象上时 -}
iObj :: a -> a
iObj = id

{- 单位自函子，作用到箭头上时 -}
iArr :: (a -> b) -> (a -> b)
iArr = id

{- 自然变换µ:T·T->T，（µ a:T·T a->T a） -}
µ :: (Applicative f) => a -> f (f a) -> f a

{- 自然变换η:I->T，（η a:I a->T a） -}
η :: (Applicative f) => a -> a -> (f a)

### 参考

[Categories for the Working Mathematician](https://book.douban.com/subject/1823110/)