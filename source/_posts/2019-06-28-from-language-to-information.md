---
layout: post
categories: Design
title: 从编程语言到信息留存

---

[计算模型](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B_(%E6%95%B0%E5%AD%A6))是[可计算性理论](https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E7%90%86%E8%AE%BA)中的一个概念，

它描述了我们根据怎样的方式，根据一组输入计算得到输出。

<br/>

计算模型有很多种，例如，

图灵机，递归函数，lambda演算，谓词逻辑，形式文法，

组合子代数，元胞自动机，等等。

<br/>

图灵机可能是最被人们所熟知的一种，

现代计算机的理论原型就是一种特殊的图灵机——[通用图灵机](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%9C%96%E9%9D%88%E6%A9%9F)，

它可以执行预先被设计好的指令序列。

<br/>

随着函数式编程语言的推广，熟悉[lambda演算](https://zh.wikipedia.org/zh/%CE%9B%E6%BC%94%E7%AE%97)的人也越来越多了，

它将计算过程，表示成了函数的定义和调用，

有着与图灵机等价的计算能力。

<br/>

对于程序员来说，这些知识都太理论了，没必要了解它们，

因为，程序无法脱离计算机体系结构而独立运行。

<br/>

目前大部分计算机都是[冯·诺伊曼结构](https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)的，

意味着程序，最终还是要被翻译CPU指令才能执行（解释型的除外），

使用其他[范式](https://zh.wikipedia.org/zh-hans/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B)进行编程，则更像是一种脑力体操罢了。

### 语言的影响

无疑编程语言会影响一个人的表述习惯，

能用直接的办法解决，多数人都不会绕着走。

<br/>

原则上，在任何一门通用编程语言中实现另一门编程语言，都没问题，

但很少有人会在，用A语言编写的程序中，嵌入B语言的代码。

几乎所有场景，都会想着用A语言的基础设施来实现。

<br/>

所以编写C代码的时候，很少有人会在[C语言](https://zh.wikipedia.org/zh-hans/C%E8%AF%AD%E8%A8%80)中先实现一个面向对象系统，

再在这个系统里面，用面向对象的方式进行编程。

即使是再不方便，很多人还是选择性的忍了。

### 把自己当做解释器

[Scheme](https://zh.wikipedia.org/zh/Scheme)对于学习语言本身来说非常适合，

因为它的求值规则足够简单，我们可以完全凭记忆跟踪下去，

就像在健身房中举铁能锻炼肌肉一样，手动跟踪代码，也能锻炼脑力。

<br/>

此外，它还会改变我们编码方式，

不同于C语言，我们不再假装自己是CPU了，而是把自己当做了一台解释器。

解释器执行什么样的代码最省力，我们就会写出什么样的代码来。

<br/>

举个例子，写Scheme时我们会更少的考虑栈溢出，

因为那是解释器自己的事情，我们只会考虑递归写法是否更贴近问题的本质。

### 系统架构

在使用面向对象编程语言，例如Java，进行编码的时候，

情况又有所不同了，它会强制我们更多的关注信息的封装和隐藏。

分治思想被应用的淋漓尽致。

<br/>

一个大型系统，通常先被人为划分为几个互通消息的子系统，

最后再集成到一起，共同提供功能。

<br/>

这似乎看起来是一件能降低复杂度的事情，其实是仁者见仁智者见智，

因为，子系统加上消息互通，构成了一个计算模型（[Object Calculus](http://lucacardelli.name/Papers/PrimObjImpSIPL.A4.pdf)），

每个子系统都会被其他系统影响，最终状态是[不可判定的](https://zh.wikipedia.org/zh-hans/%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98)。（参考，[元胞自动机](https://zh.wikipedia.org/zh-hans/%E7%B4%B0%E8%83%9E%E8%87%AA%E5%8B%95%E6%A9%9F)。

### 信息耗损

将大脑中的想法，翻译成代码，会有信息耗损，

我们损失了什么呢？

损失了无法编码到程序中的一切，尤其对于不爱写注释的那些人而言。

<br/>

我们知道，在软件项目中，实现功能只是代码的作用之一，

程序代码的另一个作用就是让别人能看懂，能继续维护下去。

那么，关注编码过程中的信息耗损就非常重要了。

<br/>

信息损耗越严重，代码腐烂的就越快。代码无法不腐烂，只是快慢而已。

那么用不同的编程范式进行编程，会导致不同的信息耗损吗？

我想会的。

<br/>

越抽象的写法，我们越难看懂作者为什么这样写。

所以语言抽象能力越强，就越要注重保留自己的编写动机。

### 结语

从计算模型的角度看待问题，常常能帮我们摆脱具体的编程范式。

<br/>

代码从程序员的角度来看，完成了符号到计算模型之间的转换，

而从计算机的角度来看，完成了从符号到底层解释设施之间的转换。

人们总是面向计算模型进行编程的，C语言提供的只是一种接近图灵机的模型而已。

<br/>

另一方面，除了关心模型，我们还要关心信息的留存，

哪些信息没有被编码到代码中，

这将更有利于写出清晰易懂的代码，也更有利于降低后续的维护成本。
